<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Aligning two coronal sections of adult mouse brain from MERFISH &mdash; STalign 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            STalign
              <img src="https://raw.githubusercontent.com/JEFworks-Lab/STalign/main/STalign_logos_fin.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#installation-import">Installation &amp; Import</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#input-data">Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#usage">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../STalign.html">Functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">STalign</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Aligning two coronal sections of adult mouse brain from MERFISH</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/merfish-merfish-alignment-affine-only-with-points.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Aligning-two-coronal-sections-of-adult-mouse-brain-from-MERFISH">
<h1>Aligning two coronal sections of adult mouse brain from MERFISH<a class="headerlink" href="#Aligning-two-coronal-sections-of-adult-mouse-brain-from-MERFISH" title="Link to this heading"></a></h1>
<p>In this notebook, we align two single cell resolution spatial transcriptomics datasets of coronal sections of the adult mouse brain from matched locations with respect to bregma assayed by MERFISH.</p>
<p>We will use <code class="docutils literal notranslate"><span class="pre">STalign</span></code> to achieve this alignment. We will first load the relevant code libraries.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>## import dependencies
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.transforms as mtransforms
import pandas as pd
import torch
import plotly
import requests

# make plots bigger
plt.rcParams[&quot;figure.figsize&quot;] = (12,10)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>## skip cell if STalign.py in same folder as notebook
import sys
sys.path.append(&quot;../../STalign&quot;)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>## import STalign from upper directory
import STalign
</pre></div>
</div>
</div>
<p>We have already downloaded single cell spatial transcriptomics datasets and placed the files in a folder called <code class="docutils literal notranslate"><span class="pre">merfish_data</span></code>.</p>
<p>We can read in the cell information for the first dataset using <code class="docutils literal notranslate"><span class="pre">pandas</span></code> as <code class="docutils literal notranslate"><span class="pre">pd</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Single cell data 1
# read in data
fname = &#39;../merfish_data/datasets_mouse_brain_map_BrainReceptorShowcase_Slice2_Replicate3_cell_metadata_S2R3.csv.gz&#39;
df1 = pd.read_csv(fname)
print(df1.head())
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
                                Unnamed: 0  fov       volume    center_x
0  158338042824236264719696604356349910479   33   532.778772  617.916619  \
1  260594727341160372355976405428092853003   33  1004.430016  596.808018
2  307643940700812339199503248604719950662   33  1267.183208  578.880018
3   30863303465976316429997331474071348973   33  1403.401822  572.616017
4  313162718584097621688679244357302162401   33   507.949497  608.364018

      center_y       min_x       max_x        min_y        max_y
0  2666.520010  614.725219  621.108019  2657.545209  2675.494810
1  2763.450012  589.669218  603.946818  2757.013212  2769.886812
2  2748.978012  570.877217  586.882818  2740.489211  2757.466812
3  2766.690012  564.937217  580.294818  2756.581212  2776.798812
4  2687.418010  603.061218  613.666818  2682.493210  2692.342810
</pre></div></div>
</div>
<p>For alignment with <code class="docutils literal notranslate"><span class="pre">STalign</span></code>, we only need the cell centroid information so we can pull out this information. We can further visualize the cell centroids to get a sense of the variation in cell density that we will be relying on for our alignment by plotting using <code class="docutils literal notranslate"><span class="pre">matplotlib.pyplot</span></code> as <code class="docutils literal notranslate"><span class="pre">plt</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># get cell centroid coordinates
xI = np.array(df1[&#39;center_x&#39;])
yI = np.array(df1[&#39;center_y&#39;])

# plot
fig,ax = plt.subplots()
ax.scatter(xI,yI,s=1,alpha=0.2, label=&#39;source&#39;)
ax.legend(markerscale = 10)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.legend.Legend at 0x1619f7fa0&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_7_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_7_1.png" />
</div>
</div>
<p>Now, we can repeat this to get cell information from the second dataset.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Single cell data 2
# read in data
fname = &#39;../merfish_data/datasets_mouse_brain_map_BrainReceptorShowcase_Slice2_Replicate2_cell_metadata_S2R2.csv.gz&#39;

df2 = pd.read_csv(fname)

# get cell centroids
xJ = np.array(df2[&#39;center_x&#39;])
yJ = np.array(df2[&#39;center_y&#39;])

# plot
fig,ax = plt.subplots()
ax.scatter(xJ,yJ,s=1,alpha=0.2,c=&#39;#ff7f0e&#39;, label=&#39;target&#39;)
ax.legend(markerscale = 10)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.legend.Legend at 0x1643a4fa0&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_9_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_9_1.png" />
</div>
</div>
<p>Note that plotting the cell centroid positions from both datasets shows that non-linear local alignment is needed.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot
fig,ax = plt.subplots()
ax.scatter(xI,yI,s=1,alpha=0.2, label=&#39;source&#39;)
ax.scatter(xJ,yJ,s=1,alpha=0.1, label= &#39;target&#39;)
ax.legend(markerscale = 10)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.legend.Legend at 0x1649b9de0&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_11_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_11_1.png" />
</div>
</div>
<p>Now, we will first use <code class="docutils literal notranslate"><span class="pre">STalign</span></code> to rasterize the single cell centroid positions into an image. Assuming the single-cell centroid coordinates are in microns, we will perform this rasterization at a 30 micron resolution. We can visualize the resulting rasterized image.</p>
<p>Note that points are plotting with the origin at bottom left while images are typically plotted with origin at top left so we’ve used <code class="docutils literal notranslate"><span class="pre">invert_yaxis()</span></code> to invert the yaxis for visualization consistency.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># rasterize at 30um resolution (assuming positions are in um units) and plot
XI,YI,I,fig = STalign.rasterize(xI,yI,dx=15,blur=1.5)

# plot
ax = fig.axes[0]
ax.invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0 of 85958
10000 of 85958
20000 of 85958
30000 of 85958
40000 of 85958
50000 of 85958
60000 of 85958
70000 of 85958
80000 of 85958
85957 of 85958
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_13_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_13_1.png" />
</div>
</div>
<p>Repeat rasterization for target dataset.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># rasterize and plot
XJ,YJ,J,fig = STalign.rasterize(xJ,yJ,dx=15, blur=1.5)
ax = fig.axes[0]
ax.invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0 of 84172
10000 of 84172
20000 of 84172
30000 of 84172
40000 of 84172
50000 of 84172
60000 of 84172
70000 of 84172
80000 of 84172
84171 of 84172
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_15_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_15_1.png" />
</div>
</div>
<p>We can also plot the rasterized images next to each other.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># get extent of images
extentI = STalign.extent_from_x((YI,XI))
extentJ = STalign.extent_from_x((YJ,XJ))

# plot rasterized images
fig,ax = plt.subplots(1,2)
ax[0].imshow(I.transpose(1,2,0).squeeze(), extent=extentI)
ax[1].imshow(J.transpose(1,2,0).squeeze(), extent=extentJ)
ax[0].invert_yaxis()
ax[1].invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_17_0.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_17_0.png" />
</div>
</div>
<p>We can manually designate a few landmark points to help initialize the alignment. A <code class="docutils literal notranslate"><span class="pre">point_annotator.py</span></code> script is provided to assist with this. In order to use the <code class="docutils literal notranslate"><span class="pre">point_annotator.py</span></code> script, we will need to write out our images as <code class="docutils literal notranslate"><span class="pre">.npz</span></code> files.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>np.savez(&#39;../merfish_data/Merfish_S2_R3&#39;, x=XI,y=YI,I=I)
np.savez(&#39;../merfish_data/Merfish_S2_R2&#39;, x=XJ,y=YJ,I=J)
</pre></div>
</div>
</div>
<p>Given these <code class="docutils literal notranslate"><span class="pre">.npz</span></code> files, we can then run the following code on the command line from inside the <code class="docutils literal notranslate"><span class="pre">notebooks</span></code> folder:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>python ../../STalign/point_annotator.py ../merfish_data/Merfish_S2_R3.npz ../merfish_data/Merfish_S2_R2.npz
</pre></div>
</div>
<p>Which will provide a graphical user interface to selecting points. These points will saved as <code class="docutils literal notranslate"><span class="pre">Merfish_S2_R3_points.npy</span></code> and <code class="docutils literal notranslate"><span class="pre">Merfish_S2_R2_points.npy</span></code> respectively. We can then read in these files.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># read from file
pointsIlist = np.load(&#39;../merfish_data/Merfish_S2_R3_points.npy&#39;, allow_pickle=True).tolist()
print(pointsIlist)
pointsJlist = np.load(&#39;../merfish_data/Merfish_S2_R2_points.npy&#39;, allow_pickle=True).tolist()
print(pointsJlist)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
{&#39;all&#39;: [(4543.712969822371, 6776.805022223103), (4996.096840790115, 6824.424377061813), (5043.716195628824, 4752.982441577941), (3067.5129698223714, 4872.030828674716), (3900.851679499791, 4776.792118997297), (7019.919421435276, 5205.366312545683), (6091.342002080437, 5014.888893190845), (1543.6936149836606, 3395.830828674716), (3186.561356919145, 3419.6405060940706), (7115.158131112696, 3729.1663125456835), (8519.92909885463, 3038.685667384392), (5258.0032924030165, 2419.6340544811665), (5091.335550467533, 705.3372802876183)]}
{&#39;all&#39;: [(6777.380999410521, 7706.03581124174), (7123.880999410521, 7405.73581124174), (5529.9809994105235, 5765.63581124174), (4305.680999410524, 7613.635811241739), (4883.180999410524, 6643.435811241739), (7239.380999410521, 4726.13581124174), (6269.180999410521, 5211.2358112417405), (2249.780999410523, 7475.03581124174), (3289.280999410523, 6158.33581124174), (6615.680999410521, 3247.7358112417405), (6638.780999410523, 2046.5358112417398), (4074.6809994105242, 3963.835811241741), (3058.280999410523, 2693.335811241741)]}
</pre></div></div>
</div>
<p>Note that these landmark points are read in as lists. We will want to convert them to a simple array for downstream usage.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># convert to array
pointsI = []
pointsJ = []

for i in pointsIlist.keys():
    for j in range(len(pointsIlist[i])):
        pointsI.append([pointsIlist[i][j][1], pointsIlist[i][j][0]])
for i in pointsJlist.keys():
    for j in range(len(pointsJlist[i])):
        pointsJ.append([pointsJlist[i][j][1], pointsJlist[i][j][0]])

pointsI = np.array(pointsI)
pointsJ = np.array(pointsJ)
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># now arrays
print(pointsI)
print(pointsJ)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[6776.80502222 4543.71296982]
 [6824.42437706 4996.09684079]
 [4752.98244158 5043.71619563]
 [4872.03082867 3067.51296982]
 [4776.792119   3900.8516795 ]
 [5205.36631255 7019.91942144]
 [5014.88889319 6091.34200208]
 [3395.83082867 1543.69361498]
 [3419.64050609 3186.56135692]
 [3729.16631255 7115.15813111]
 [3038.68566738 8519.92909885]
 [2419.63405448 5258.0032924 ]
 [ 705.33728029 5091.33555047]]
[[7706.03581124 6777.38099941]
 [7405.73581124 7123.88099941]
 [5765.63581124 5529.98099941]
 [7613.63581124 4305.68099941]
 [6643.43581124 4883.18099941]
 [4726.13581124 7239.38099941]
 [5211.23581124 6269.18099941]
 [7475.03581124 2249.78099941]
 [6158.33581124 3289.28099941]
 [3247.73581124 6615.68099941]
 [2046.53581124 6638.78099941]
 [3963.83581124 4074.68099941]
 [2693.33581124 3058.28099941]]
</pre></div></div>
</div>
<p>We can double check that our landmark points look sensible by plotting them along with the rasterized image we created.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot

fig,ax = plt.subplots(1,2)
ax[0].imshow((I.transpose(1,2,0).squeeze()), extent=extentI)
ax[1].imshow((J.transpose(1,2,0).squeeze()), extent=extentJ)

trans_offset_0 = mtransforms.offset_copy(ax[0].transData, fig=fig,
                                       x=0.05, y=-0.05, units=&#39;inches&#39;)
trans_offset_1 = mtransforms.offset_copy(ax[1].transData, fig=fig,
                                       x=0.05, y=-0.05, units=&#39;inches&#39;)

ax[0].scatter(pointsI[:,1],pointsI[:,0], c=&#39;red&#39;, s=10)
ax[1].scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;red&#39;, s=10)

for i in pointsIlist.keys():
    for j in range(len(pointsIlist[i])):
        ax[0].text(pointsIlist[i][j][0], pointsIlist[i][j][1],f&#39;{i}{j}&#39;, c=&#39;red&#39;, transform=trans_offset_0, fontsize= 8)
for i in pointsJlist.keys():
    for j in range(len(pointsJlist[i])):
        ax[1].text(pointsJlist[i][j][0], pointsJlist[i][j][1],f&#39;{i}{j}&#39;, c=&#39;red&#39;, transform=trans_offset_1, fontsize= 8)

ax[0].set_title(&#39;source with pointsI&#39;, fontsize=15)
ax[1].set_title(&#39;target with pointsJ&#39;, fontsize=15)

# invert only rasterized images
ax[0].invert_yaxis()
ax[1].invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_26_0.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_26_0.png" />
</div>
</div>
<p>From the landmark points, we can generate a linear transformation <code class="docutils literal notranslate"><span class="pre">L</span></code> and translation <code class="docutils literal notranslate"><span class="pre">T</span></code> which will produce a simple initial affine transformation <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># set device for building tensors
if torch.cuda.is_available():
    torch.set_default_device(&#39;cuda:0&#39;)
else:
    torch.set_default_device(&#39;cpu&#39;)
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># compute initial affine transformation from points
L,T = STalign.L_T_from_points(pointsI,pointsJ)
A = STalign.to_A(torch.tensor(L),torch.tensor(T))
</pre></div>
</div>
</div>
<p>We can show the results of the simple affine transformation on the rasterized source image.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># compute initial affine transformation from points
AI= STalign.transform_image_source_with_A(A, [YI,XI], I, [YJ,XJ])

fig,ax = plt.subplots(1,2)

if AI.is_cuda:
    ax[0].imshow((AI.cpu().permute(1,2,0).squeeze()), extent=extentJ)
else:
    ax[0].imshow((AI.permute(1,2,0).squeeze()), extent=extentJ)
ax[1].imshow((J.transpose(1,2,0).squeeze()), extent=extentJ)

ax[0].set_title(&#39;source with affine transformation&#39;, fontsize=15)
ax[1].set_title(&#39;target&#39;, fontsize=15)

# invert only rasterized images
ax[0].invert_yaxis()
ax[1].invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area stderr docutils container">
<div class="highlight"><pre>
/Users/kalenclifton/.local/share/virtualenvs/STalign-wXTCUYXW/lib/python3.10/site-packages/torch/utils/_device.py:62: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).
  return func(*args, **kwargs)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_31_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_31_1.png" />
</div>
</div>
<p>Finally, we can apply our affine transform to the original sets of single cell centroid positions to achieve their new aligned positions.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#apply A to sources points in row, column (y,x) orientation
affine = np.matmul(np.array(A.cpu()),np.array([yI, xI, np.ones(len(xI))]))

xIaffine = affine[1,:]
yIaffine = affine[0,:]
</pre></div>
</div>
</div>
<p>And we can visualize the results.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot results
fig,ax = plt.subplots()
ax.scatter(xI,yI,s=1,alpha=0.1, label=&#39;source&#39;)
ax.scatter(xIaffine,yIaffine,s=1,alpha=0.1, label = &#39;source aligned&#39;)
ax.scatter(xJ,yJ,s=1,alpha=0.1, label=&#39;target&#39;)
ax.legend(markerscale = 10)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.legend.Legend at 0x164edd120&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_35_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_35_1.png" />
</div>
</div>
<p>And save the new aligned positions by appending to our original data</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>df3 = pd.DataFrame(

    {

        &quot;aligned_x&quot;: xIaffine,

        &quot;aligned_y&quot;: yIaffine,

    },


)

results = pd.concat([df1, df3], axis=1)
results.head()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>fov</th>
      <th>volume</th>
      <th>center_x</th>
      <th>center_y</th>
      <th>min_x</th>
      <th>max_x</th>
      <th>min_y</th>
      <th>max_y</th>
      <th>aligned_x</th>
      <th>aligned_y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>158338042824236264719696604356349910479</td>
      <td>33</td>
      <td>532.778772</td>
      <td>617.916619</td>
      <td>2666.520010</td>
      <td>614.725219</td>
      <td>621.108019</td>
      <td>2657.545209</td>
      <td>2675.494810</td>
      <td>1144.886231</td>
      <td>7614.195863</td>
    </tr>
    <tr>
      <th>1</th>
      <td>260594727341160372355976405428092853003</td>
      <td>33</td>
      <td>1004.430016</td>
      <td>596.808018</td>
      <td>2763.450012</td>
      <td>589.669218</td>
      <td>603.946818</td>
      <td>2757.013212</td>
      <td>2769.886812</td>
      <td>1197.052502</td>
      <td>7703.386882</td>
    </tr>
    <tr>
      <th>2</th>
      <td>307643940700812339199503248604719950662</td>
      <td>33</td>
      <td>1267.183208</td>
      <td>578.880018</td>
      <td>2748.978012</td>
      <td>570.877217</td>
      <td>586.882818</td>
      <td>2740.489211</td>
      <td>2757.466812</td>
      <td>1174.838094</td>
      <td>7706.104535</td>
    </tr>
    <tr>
      <th>3</th>
      <td>30863303465976316429997331474071348973</td>
      <td>33</td>
      <td>1403.401822</td>
      <td>572.616017</td>
      <td>2766.690012</td>
      <td>564.937217</td>
      <td>580.294818</td>
      <td>2756.581212</td>
      <td>2776.798812</td>
      <td>1182.723315</td>
      <td>7724.233148</td>
    </tr>
    <tr>
      <th>4</th>
      <td>313162718584097621688679244357302162401</td>
      <td>33</td>
      <td>507.949497</td>
      <td>608.364018</td>
      <td>2687.418010</td>
      <td>603.061218</td>
      <td>613.666818</td>
      <td>2682.493210</td>
      <td>2692.342810</td>
      <td>1152.710375</td>
      <td>7637.229823</td>
    </tr>
  </tbody>
</table>
</div></div>
</div>
<p>We will finally create a compressed <code class="docutils literal notranslate"><span class="pre">.csv.gz</span></code> file named <code class="docutils literal notranslate"><span class="pre">mouse_brain_map_BrainReceptorShowcase_Slice2_Replicate3_STalign_to_Slice2_Replicate2.csv.gz</span></code></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>results.to_csv(&#39;../merfish_data/mouse_brain_map_BrainReceptorShowcase_Slice2_Replicate3_STalign_to_Slice2_Replicate2_affine_only_with_points.csv.gz&#39;,
               compression=&#39;gzip&#39;)
</pre></div>
</div>
</div>
<p>To further analyze our results we can measure the target registration error (TRE) of the landmarks (between source and target) before and after alignment. To do that, first we need to apply the affine alignment to the source landmark points.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>#apply A to sources landmark points in row, column (y,x) orientation
ypointsI = pointsI[:,0]
xpointsI = pointsI[:,1]
affine = np.matmul(np.array(A.cpu()),np.array([ypointsI, xpointsI, np.ones(len(ypointsI))]))

xpointsIaffine = affine[1,:]
ypointsIaffine = affine[0,:]
pointsIaffine = np.column_stack((ypointsIaffine,xpointsIaffine))
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(pointsIaffine)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[7729.29343674 6656.15725019]
 [7421.11687713 6998.47047486]
 [5821.96940059 5607.52920106]
 [7414.99213008 4336.92872391]
 [6709.25420423 4841.77352617]
 [4660.09861705 7270.82747883]
 [5222.70391486 6504.45726932]
 [7460.27645534 2279.63529464]
 [6228.59341962 3420.29244766]
 [3473.84607841 6321.53466748]
 [1884.33147259 6808.37830237]
 [3898.43476186 4150.66032244]
 [2731.75477764 2858.50803342]]
</pre></div></div>
</div>
<p>We can get the mean TRE across landmark points by using <code class="docutils literal notranslate"><span class="pre">STalign.calculate_tre</span></code></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>treBefore = STalign.calculate_tre(pointsI,pointsJ)
treAffine = STalign.calculate_tre(pointsIaffine,pointsJ)

print(&quot;The mean TRE of landmarks before alignment is {:.0f} +/- {:.2f}&quot;.format(treBefore[0], treBefore[1] ))
print(&quot;The mean TRE of landmarks after affine alignment is {:.0f} +/- {:.2f}&quot;.format(treAffine[0], treAffine[1] ))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The mean TRE of landmarks before alignment is 2011 +/- 1065.47
The mean TRE of landmarks after affine alignment is 156 +/- 87.61
</pre></div></div>
</div>
<p>Alternatively, we can look at the TRE for each target and source pair of landmark points</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>treBefore = np.sqrt(np.sum((pointsI - pointsJ)**2,axis=1))
treAffine = np.sqrt(np.sum((pointsIaffine - pointsJ)**2,axis=1))
print(treBefore)
print(treAffine)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[2419.2442468  2205.76254597 1123.35226287 3008.23169818 2109.34339702
  527.09131807  264.91285586 4139.86384852 2740.62096967  693.72381585
 2126.75327885 1945.45899846 2843.49238906]
[123.43465688 126.3502151   95.84986629 201.08638033  77.76014208
  73.14227289 235.55559977  33.30341619 148.66112843 371.00932267
 234.67742254 100.25046029 203.43366221]
</pre></div></div>
</div>
<p>We can plot the TRE before alignment on each of the target landmarks</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot

fig,ax = plt.subplots()
ax.imshow((J.transpose(1,2,0).squeeze()), extent=extentJ)

trans_offset_0 = mtransforms.offset_copy(ax.transData, fig=fig,
                                       x=0.05, y=-0.05, units=&#39;inches&#39;)

ax.scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;red&#39;, s=10, label=&#39;Target&#39;)
#ax.scatter(pointsI[:,1],pointsI[:,0], c=&#39;orange&#39;, s=10, label=&#39;Source&#39;)

#k=0
#for i in pointsIlist.keys():
#    for j in range(len(pointsIlist[i])):
#        ax.text(pointsIlist[i][j][0], pointsIlist[i][j][1],f&#39;{treBefore[k]:.0f}&#39;, c=&#39;red&#39;, transform=trans_offset_0, fontsize= 15)
#        k = k+1

for i in range(pointsJ.shape[0]):
    ax.text(pointsJ[i,1],pointsJ[i,0],f&#39;{treBefore[i]:.0f}&#39;, c=&#39;red&#39;, transform=trans_offset_0, fontsize= 15)

ax.set_title(&#39;TRE Before Alignment&#39;, fontsize=15)

ax.legend(markerscale = 1)
# invert only rasterized images
ax.invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_48_0.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_48_0.png" />
</div>
</div>
<p>Next plot shows a reminder of what the landmarks of source and target looked like before alignment</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot
fig,ax = plt.subplots()
ax.scatter(xI,yI,s=1,alpha=0.2, label=&#39;source&#39;)
ax.scatter(xJ,yJ,s=1,alpha=0.1, label= &#39;target&#39;)
ax.legend(markerscale = 10)
ax.scatter(pointsI[:,1],pointsI[:,0], c=&#39;purple&#39;, s=10, label=&#39;Source&#39;)
ax.scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;green&#39;, s=10, label=&#39;Target&#39;)
ax.set_title(&#39;Before Alignment&#39;, fontsize=15)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 1.0, &#39;Before Alignment&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_50_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_50_1.png" />
</div>
</div>
<p>We can plot the TRE after alignment on each of the target landmarks along with the source landmarks after affine alignment.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot

fig,ax = plt.subplots()
ax.imshow((J.transpose(1,2,0).squeeze()), extent=extentJ)

trans_offset_0 = mtransforms.offset_copy(ax.transData, fig=fig,
                                       x=0.05, y=-0.05, units=&#39;inches&#39;)

ax.scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;red&#39;, s=10, label=&#39;Target&#39;)
ax.scatter(pointsIaffine[:,1],pointsIaffine[:,0], c=&#39;orange&#39;, s=10, label=&quot;Affine Alignment&quot;)

#k=0
#for i in pointsIlist.keys():
#    for j in range(len(pointsIlist[i])):
#        ax.text(pointsIlist[i][j][0], pointsIlist[i][j][1],f&#39;{treAffine[k]:.0f}&#39;, c=&#39;red&#39;, transform=trans_offset_0, fontsize= 15)
#        k = k+1

for i in range(pointsJ.shape[0]):
    ax.text(pointsJ[i,1],pointsJ[i,0],f&#39;{treAffine[i]:.0f}&#39;, c=&#39;red&#39;, transform=trans_offset_0, fontsize= 15)

ax.set_title(&#39;TRE After Affine Alignment&#39;, fontsize=15)

ax.legend(markerscale = 1)

# invert only rasterized images
ax.invert_yaxis()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_52_0.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_52_0.png" />
</div>
</div>
<p>More summary plots of alignment below:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[76]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot results
fig,ax = plt.subplots()
ax.scatter(xI,yI,s=1,alpha=0.1, label=&#39;source&#39;)
ax.scatter(xIaffine,yIaffine,s=1,alpha=0.1, label = &#39;source aligned&#39;)
ax.scatter(xJ,yJ,s=1,alpha=0.1, label=&#39;target&#39;)
ax.legend(markerscale = 10)
#ax.scatter(pointsI[:,1],pointsI[:,0], c=&#39;purple&#39;, s=10, label=&#39;Source&#39;)
ax.scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;green&#39;, s=10, label=&#39;Target&#39;)
ax.scatter(pointsIaffine[:,1],pointsIaffine[:,0], c=&#39;red&#39;, s=10, label=&quot;Affine Alignment&quot;)
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[76]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;matplotlib.collections.PathCollection at 0x7f8d8b4a3940&gt;
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_54_1.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_54_1.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot results
fig,ax = plt.subplots(2,2)

#Source
ax[0][0].scatter(xI,yI,s=1,alpha=0.1, label=&#39;source cells&#39;)
ax[0][0].scatter(pointsI[:,1],pointsI[:,0], c=&#39;blue&#39;, s=10, label=&#39;source landmarks&#39;)
ax[0][0].set_title(&#39;Source&#39;, fontsize=15)
ax[0][0].set_aspect(&#39;equal&#39;)

lgnd = ax[0][0].legend(scatterpoints=1, fontsize=10)
for handle in lgnd.legend_handles:
    handle.set_sizes([10.0])

#Target
ax[0][1].scatter(xJ,yJ,s=1,alpha=0.1, label=&#39;target cells&#39;, c=&#39;orange&#39;)
ax[0][1].scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;red&#39;, s=10, label=&#39;target landmarks&#39;)
ax[0][1].set_title(&#39;Target&#39;, fontsize=15)
ax[0][1].set_aspect(&#39;equal&#39;)

lgnd = ax[0][1].legend(scatterpoints=1, fontsize=10)
for handle in lgnd.legend_handles:
    handle.set_sizes([10.0])

#Affine Aligned Source
ax[1][0].scatter(xIaffine,yIaffine,s=1,alpha=0.1, label = &#39;affine aligned source cells&#39;, c=&#39;blue&#39;)
ax[1][0].scatter(pointsIaffine[:,1],pointsIaffine[:,0], c=&#39;purple&#39;, s=10, label=&quot;affine aligned source landmarks&quot;)
ax[1][0].set_title(&#39;Affine Aligned Source&#39;, fontsize=15)
ax[1][0].set_aspect(&#39;equal&#39;)

lgnd = ax[1][0].legend(scatterpoints=1, fontsize=10)
for handle in lgnd.legend_handles:
    handle.set_sizes([10.0])

#Overlay of Target and Affine Aligned Source
ax[1][1].scatter(xJ,yJ,s=1,alpha=0.1, label=&#39;target&#39;, c=&#39;orange&#39;)
ax[1][1].legend(markerscale = 10)
ax[1][1].scatter(pointsJ[:,1],pointsJ[:,0], c=&#39;red&#39;, s=10, label=&#39;target landmarks&#39;)

ax[1][1].scatter(xIaffine,yIaffine,s=1,alpha=0.1, label = &#39;source aligned&#39;, c=&#39;blue&#39;)
ax[1][1].scatter(pointsIaffine[:,1],pointsIaffine[:,0], c=&#39;purple&#39;, s=10, label=&quot;affine aligned source landmarks&quot;)
ax[1][1].set_title(&#39;Overlay&#39;, fontsize=15)
ax[1][1].set_aspect(&#39;equal&#39;)

lgnd = ax[1][1].legend(scatterpoints=1, fontsize=10)
for handle in lgnd.legend_handles:
    handle.set_sizes([10.0])
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_55_0.png" src="../_images/notebooks_merfish-merfish-alignment-affine-only-with-points_55_0.png" />
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, JEFworks Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>